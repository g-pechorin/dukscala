#import(peterlavalle.scad40.Model)
<%@ val modelModule: Model.Module %>
<%@ val modelNative: Model.Native %>
<%@ val nephrite: peterlavalle.scad40.Nephrite %>
#{
		val modelNameSpace = modelModule.name.replace(".", "::")
		val declarationNameSpace = modelNameSpace  + "::" + modelNative.name
}#


#pragma region "native ${modelNative.name}"
inline bool ${declarationNameSpace}::Is(duk_context* ctx, duk_idx_t idx)
{
	// stack -> ... ; ?[T]? ;
	if (!duk_is_object(ctx, idx))
	{
		return false;
	}
	duk_get_prop_string(ctx, idx, "\xFF" "typeid().name()");
	// stack -> ... ; ?[T]? ; ?"${modelNative.name}"? ;
	const bool matches = strcmp(typeid(${declarationNameSpace}).name(), duk_to_string(ctx, -1)) ? false : true;
	duk_pop(ctx);
	// stack -> ... ; ?[T]? ;
	return matches;
}
inline scad40::duk_ref<${declarationNameSpace}> ${declarationNameSpace}::New(duk_context* ctx)
{
	${modelNative.name}* this${modelNative.name} = (${modelNative.name}*)duk_alloc(ctx, sizeof(${modelNative.name}));

	const auto idxBase = duk_get_top(ctx);
	// stack -> ... ;

	duk_push_object(ctx);
	// stack -> ... ; [${modelNative.name}] ;

	scad40::push_selfie< ${declarationNameSpace} >(ctx, this${modelNative.name}, 0, [](duk_context* ctx, ${declarationNameSpace}* this${modelNative.name}) -> duk_ret_t {
		this${modelNative.name}->~${modelNative.name}();
		duk_free(ctx, this${modelNative.name});
		return 0;
	});
	// stack -> ... ; [${modelNative.name}] ; ~${modelNative.name}() ;

	duk_set_finalizer(ctx, idxBase);
	// stack -> ... ; [${modelNative.name}] ;

	duk_push_string(ctx, typeid(${declarationNameSpace}).name());
	// stack -> ... ; [${modelNative.name}] ; typeid(${declarationNameSpace}).name() ;

	duk_put_prop_string(ctx, idxBase, "\xFF" "typeid().name()");
	// stack -> ... ; [${modelNative.name}] ;

	duk_push_pointer(ctx, this${modelNative.name});
	// stack -> ... ; [${modelNative.name}] ; *${modelNative.name} ;

	duk_put_prop_string(ctx, idxBase, "\xFF" "*");
	// stack -> ... ; [${modelNative.name}] ;

	{
#for (member <- modelNative.members.filterNot(_.isInstanceOf[Model.MemberRaw]))
		// ${member.source}
			${nephrite.sub("/native")("\n\t\t\t", member)}

#end
	}
	// stack -> ... ; [${modelNative.name}] ;

	*reinterpret_cast${"<duk_context**>"}(this${modelNative.name}) = ctx;
	auto t = duk_get_top(ctx);
	new (this${modelNative.name})${modelNative.name}();
	assert(t == duk_get_top(ctx));
	auto ret = scad40::duk_ref<${modelNative.name}>(ctx, -1);
	assert((t) == duk_get_top(ctx));
	// stack -> ... ; [${modelNative.name}] ;

	duk_pop(ctx);
	assert(!ret.IsNull());
	assert(nullptr != ret.operator ->());
	return ret;
}

inline scad40::duk_ref<${declarationNameSpace}> ${declarationNameSpace}::To(duk_context* ctx, duk_idx_t idx)
{
	if (!${declarationNameSpace}::Is(ctx, idx))
	{
		duk_error(ctx, 314, "Tried to grab `%s` as a {${modelNative.name}} (which it is not)", duk_to_string(ctx, idx));
	}
	return scad40::duk_ref< ${declarationNameSpace} >(ctx, idx);
}
#pragma endregion
