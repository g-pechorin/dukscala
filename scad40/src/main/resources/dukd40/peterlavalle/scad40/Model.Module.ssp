#import(peterlavalle.scad40.Model)
<%@ val modelModule: Model.Module %>
<%@ val nephrite: peterlavalle.scad40.Nephrite %>
#{val modelNameSpace = modelModule.name.replace(".", "::")}#
${include("scad40-head.ssp")}

#for (space <- modelModule.name.split("\\\\."))
namespace ${space + " {"}
#end

#for (struct <- modelModule.contents)
	/// a ${struct.getClass.getSimpleName.toLowerCase} class
	${nephrite("\n\t", struct)}

#end

	/// sets up the tables and calls to this VM
	inline void install(duk_context* ctx)
	{
		auto base = duk_get_top(ctx);

		// >> check for name collisions
		{
			// stack -> .... base .. ;

			scad40::env::lookup(ctx, "${modelModule.name}");
			// stack -> .... base .. ; ?? previous ?? ;

			if (!duk_is_undefined(ctx, -1))
			{
				duk_error(ctx, 314, "Can't redefine module `${modelModule.name}`");
				return;
			}
			// stack -> .... base .. ; <undefined> ;

			duk_pop(ctx);
			// stack -> .... base .. ;

			assert(duk_get_top(ctx) == base);
		};


		// >> bind lambdas for native class construction
		#for (struct <- modelModule.contents.filter(_.isInstanceOf[Model.Native]))

		{
			<%-- should probably peel these out into templates of their own --%>
			// stack -> .... base .. ;

			duk_push_c_function(ctx, [](duk_context* ctx) -> duk_ret_t {

				duk_error(ctx, 314, "??? STUB ; scad40 needs to create an instance of ${modelModule.name}.${struct.name}");
				return -1;

			}, 0);
			// stack -> .... base .. ; class:${struct.name}() ;

			scad40::env::assign(ctx, "${modelModule.name}.${struct.name}");
			// stack -> .... base .. ;

			assert(duk_get_top(ctx) == base);
		}
		#end

		// >> load up code to wrap scripts
		{
			// assert(false && "?? load up code to make script super-classes");
			// assert(false && "... is there anything to do here? is this redundant?");
		}

		// >> allocate / in-place-new and store ALL global objects (including context pointers)
		{
			// stack -> .... base .. ;
			#for (struct <- modelModule.contents.filter(_.isInstanceOf[Model.Global]))

			// ${modelModule.name}/${struct.name}
			{
				${nephrite.sub("/global-member")("\n\t\t\t\t", struct)}
			}
			#end

		}
	}
}
}

${ "#ifndef" } _scad40_tail
${ "#define" } _scad40_tail

${include("scad40-tail.ssp")}
${include("scad40-duk_str.ssp")}
${include("scad40-duk_obj.ssp")}
${include("scad40-duk_ref.ssp")}
${include("scad40-object.ssp")}

${ "#endif" } // ... okay - that's the end of predef


// =====================================================================================================================
// boilerplate usercode implementations - these things wrap/cast/adapt stuff for your "real" methods
// ---------------------------------------------------------------------------------------------------------------------

#for (struct <- modelModule.contents)
${nephrite.sub("/tailcode")(struct)}
#end
