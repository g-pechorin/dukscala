
#pragma region "scad40 and scad40::env"
inline bool scad40::has_prop(duk_context* ctx, const duk_idx_t idx, const char* key)
{
	// stack -> .. idx ... ;

	duk_get_prop_string(ctx, idx, key);
	// stack -> .. idx ... ; value ;

	const bool result = duk_is_null_or_undefined(ctx, -1) ? false : true;

	duk_pop(ctx);
	// stack -> .. idx ... ;

	return result;
}

template<${"typename T"}>
inline void scad40::push_selfie<${"T"}>(duk_context* ctx, T* self, duk_idx_t nargs, duk_ret_t(*code)(duk_context*, T*))
{
	duk_push_c_function(ctx, [](duk_context* ctx) -> duk_ret_t {
		duk_push_current_function(ctx);
		duk_get_prop_string(ctx, -1, "\xFF" "self");
		duk_get_prop_string(ctx, -2, "\xFF" "code");
		auto self = (T*)duk_to_pointer(ctx, -2);
		auto code = (duk_ret_t(*)(duk_context*, T*))duk_to_pointer(ctx, -1);
		duk_pop_3(ctx);
		return code(ctx, self);
	}, nargs);
	duk_push_pointer(ctx, self);
	duk_put_prop_string(ctx, -2, "\xFF" "self");
	duk_push_pointer(ctx, code);
	duk_put_prop_string(ctx, -2, "\xFF" "code");
}

inline void scad40::env::assign(duk_context* ctx, const char* key)
{
	size_t idx = 0, len = 0;

	const auto val = duk_get_top(ctx);
	// stack -> ... ; val ;

	duk_push_global_object(ctx);
	// stack -> ... ; val ; [global host] ;

	while (key[idx + len])
	{
		// stack -> ... ; val ; [host] ;

		if ('.' != key[idx + len])
		{
			++len;
		}
		else
		{
			duk_push_lstring(ctx, key + idx, len);
			// stack -> ... ; val ; [outer host] ; "key" ;

			duk_get_prop(ctx, -2);
			// stack -> ... ; val ; [outer host] ; ?[inner host]? ;

			if (duk_is_null_or_undefined(ctx, -1))
			{
				// stack -> ... ; val ; [outer host] ; <undefined> ;

				duk_pop(ctx);
				// stack -> ... ; val ; [outer host] ;

				duk_push_object(ctx);
				// stack -> ... ; val ; [outer host] ; [inner host] ;

				duk_push_lstring(ctx, key + idx, len);
				// stack -> ... ; val ; [outer host] ; [inner host] ; "key" ;

				duk_dup(ctx, -2);
				// stack -> ... ; val ; [outer host] ; [inner host] ; "key" ; [inner host] ;

				duk_put_prop(ctx, -4);
				// stack -> ... ; val ; [outer host] ; [inner host] ;
			}
			else if (!duk_is_object(ctx, -1))
			{
				duk_push_lstring(ctx, key, idx + len);
				duk_error(ctx, 314, "Collision `%s`", duk_to_string(ctx, -1));
				return;
			}

			// stack -> ... ; val ; [outer host] ; [inner host] ;

			duk_remove(ctx, -2);
			// stack -> ... ; val ; [inner host] ;

			idx = idx + len + 1;
			len = 0;
		}
	}

	// stack -> ... ; val ; [host] ;

	duk_push_lstring(ctx, key + idx, len);
	// stack -> ... ; val ; [host] ; "key" ;

	duk_dup(ctx, -3);
	// stack -> ... ; val ; [host] ; "key" ; val ;

	duk_remove(ctx, -4);
	// stack -> ... ; [host] ; "key" ; val ;

	duk_put_prop(ctx, -3);
	// stack -> ... ; [host] ;

	duk_pop(ctx);
	// stack -> ... ;

}

inline bool scad40::env::exists(duk_context* ctx, const char* path)
{
	// stack -> .... base .. ;

	scad40::env::lookup(ctx, path);
	// stack -> .... base .. ; ??? ;

	const auto result = duk_is_null_or_undefined(ctx, -1) ? false : true;

	duk_pop(ctx);
	// stack -> .... base .. ;

	return result;
}

inline void scad40::env::lookup(duk_context* ctx, const char* binding)
{
	size_t idx = 0, len = 0;

	auto base = duk_get_top(ctx);
	// stack -> .... base .. ;

	duk_push_global_object(ctx);
	// stack -> .... base .. ; [global host] ;

	while (binding[idx + len])
	{
		// stack -> .... base .. ; [host] ;
		if ('.' != binding[idx + len])
		{
			++len;
		}
		else
		{
			duk_push_lstring(ctx, binding + idx, len);
			// stack -> .... base .. ; [outer host] ; "key" ;

			assert((2 + base) == duk_get_top(ctx));
			duk_get_prop(ctx, -2);
			// stack -> .... base .. ; [outer host] ; ?[inner host]? ;

			if (duk_is_null_or_undefined(ctx, -1))
			{
				duk_pop_2(ctx);
				// stack -> .... base .. ;

				assert(base == duk_get_top(ctx));
				duk_push_undefined(ctx);
				// stack -> .... base .. ; <undefined> ;

				return;
			}

			// stack -> .... base .. ; [outer host] ; [inner host] ;

			duk_remove(ctx, base);
			// stack -> .... base .. ; [inner host] ;

			idx = idx + len + 1;
			len = 0;
		}
	}

	assert(0 != len);
	// stack -> .... base .. ; [host] ;

	duk_get_prop_string(ctx, -1, binding + idx);
	// stack -> .... base .. ; [host] ; val ;

	duk_remove(ctx, -2);
	// stack -> .... base .. ; val ;
}

inline void scad40::env::remove(duk_context* ctx, const char* binding)
{
	size_t idx = 0, len = 0;

	auto base = duk_get_top(ctx);
	// stack -> .... base .. ;

	duk_push_global_object(ctx);
	// stack -> .... base .. ; [global host] ;

	while (binding[idx + len])
	{
		// stack -> .... base .. ; [host] ;
		if ('.' != binding[idx + len])
		{
			++len;
		}
		else
		{
			const char* key = duk_push_lstring(ctx, binding + idx, len);
			// stack -> .... base .. ; [outer host] ; "key" ;

			assert((2 + base) == duk_get_top(ctx));
			duk_get_prop(ctx, -2);
			// stack -> .... base .. ; [outer host] ; ?[inner host]? ;

			if (duk_is_null_or_undefined(ctx, -1))
			{
				duk_pop_2(ctx);
				// stack -> .... base .. ;

				return;
			}

			// stack -> .... base .. ; [outer host] ; [inner host] ;

			duk_remove(ctx, base);
			// stack -> .... base .. ; [inner host] ;

			idx = idx + len + 1;
			len = 0;
		}
	}

	assert(0 != len);
	assert(0 == binding[idx + len]);
	assert((base + 1) == duk_get_top(ctx));
	// stack -> .... base .. ; [host] ;

	duk_del_prop_string(ctx, -1, binding + idx);
	// stack -> .... base .. ; [host] ;

	duk_pop(ctx);
	// stack -> .... base .. ;
}
#pragma endregion

#pragma region "object / handle"
inline scad40::_object::_object(duk_context* ctx) :
	_ctx(ctx)
{
	assert(nullptr != _ctx);
}

inline scad40::_handle::_handle(const scad40::_handle& other) : scad40::_object(other)
{
	duk_push_global_stash(_ctx);
	duk_get_prop_string(Host(), -1, other.KeyString().data());
	duk_put_prop_string(Host(), -2, KeyString().data());
	duk_pop(_ctx);
}

inline duk_context* scad40::_object::Host(void) const
{
	return _ctx;
}

inline bool scad40::_handle::IsNull(void) const
{
	// stack -> ... ;

	duk_push_global_stash(Host());
	// stack -> ... ; [global stash] ;

	duk_get_prop_string(Host(), -1, KeyString().data());
	// stack -> ... ; [global stash] ; ??thing?? ;

	const bool result = duk_is_null_or_undefined(Host(), -1) ? true : false;

	duk_pop_2(Host());
	// stack -> ... ;

	return result;
}

inline std::array<char, scad40__pre_strlen + (sizeof(void*) * 2) + 1> scad40::_handle::KeyString(void) const
{
	assert(strlen(scad40__pre_string) == scad40__pre_strlen);
	std::array<char, scad40__pre_strlen + (sizeof(void*) * 2) + 1> result;

	strcpy(result.data(), scad40__pre_string);
	size_t write = scad40__pre_strlen;

	union {
		uint8_t _chars[(sizeof(void*) * 2)];
		void* _cast;
	} swang;

	swang._cast = const_cast<void*>(reinterpret_cast<const void*>(this));

	for (size_t i = 0; i < sizeof(void*); ++i)
	{
		uint8_t pair = swang._chars[i];

		result[write++] = 'A' + (pair & 0x0F);
		result[write++] = 'A' + ((pair & 0xF0) >> 4);
	}

	result[write] = '\0';

	return result;
}

inline void scad40::_handle::Push(void) const
{
	duk_push_global_stash(Host());
	duk_get_prop_string(Host(), -1, KeyString().data());
	duk_remove(Host(), -2);
}

inline scad40::_handle& scad40::_handle::operator=(const scad40::_handle& other)
{
	assert(Host() == other.Host());

	duk_push_global_stash(_ctx);
	duk_get_prop_string(Host(), -1, other.KeyString().data());
	duk_put_prop_string(Host(), -2, KeyString().data());
	duk_pop(_ctx);

	return *this;
}
#pragma endregion

#pragma region "duk_str"
inline scad40::duk_str::duk_str(duk_context* ctx, const char* str) :
	scad40::_native<const char>(ctx)
{
	duk_push_global_stash(ctx);
	if (nullptr == str)
	{
		duk_push_undefined(ctx);
		_pointer = nullptr;
	}
	else
	{
		_pointer = duk_push_string(ctx, str);
	}
	duk_put_prop_string(ctx, -2, KeyString().data());
	duk_pop(ctx);
}

inline scad40::duk_str::duk_str(duk_context* ctx, duk_idx_t idx) :
	scad40::_native<const char>(ctx)
{
	assert(duk_is_string(ctx, idx));

	idx = duk_normalize_index(ctx, idx);

	// stack -> ... ; "val" ; ... ;

	duk_push_global_stash(ctx);
	// stack -> ... ; "val" ; ... ; [global stash] ;

	duk_dup(ctx, idx);
	// stack -> ... ; "val" ; ... ; [global stash] ; "val" ;

	_pointer = duk_is_null_or_undefined(ctx, -1) ? nullptr : duk_to_string(ctx, -1);

	duk_put_prop_string(ctx, -2, KeyString().data());
	// stack -> ... ; "val" ; ... ; [global stash] ;

	duk_pop(ctx);
	// stack -> ... ; "val" ; ... ;
}
#pragma endregion

#pragma region "duk_ref"
template<${"typename T"}>
inline scad40::duk_ref<${"T"}>::duk_ref(duk_context* ctx, const duk_idx_t idx) :
	scad40::_native<${"T"}>(ctx)
{
	assert(T::Is(ctx, idx));
	// stack -> ... ; [T] ; ... ;

	duk_get_prop_string(ctx, idx, "\xFF" "*");
	// stack -> ... ; [T] ; ... ; T* ;

	_pointer = (T*)duk_to_pointer(ctx, -1);

	duk_pop(ctx);
	// stack -> ... ; [T] ; ... ;

	duk_push_global_stash(ctx);
	// stack -> ... ; [T] ; ... ; [global stash] ;

	duk_dup(ctx, idx);
	// stack -> ... ; [T] ; ... ; [global stash] ; [T] ;

	duk_put_prop_string(ctx, -2, KeyString().data());
	// stack -> ... ; [T] ; ... ; [global stash] ;

	duk_pop(ctx);
	// stack -> ... ; [T] ; ... ;
}
#pragma endregion

inline std::ostream& operator<<(std::ostream& ostream, const scad40::duk_str& string)
{
	return ostream << static_cast<${"const"} char*>(string);
}
