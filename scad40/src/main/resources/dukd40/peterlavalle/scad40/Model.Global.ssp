#import(peterlavalle.scad40.Model)
<%@ val modelGlobal: Model.Global %>
<%@ val nephrite: peterlavalle.scad40.Nephrite %>
struct ${modelGlobal.name} : public scad40::object
{
	/// the ${modelGlobal.name} constructor
	/// ... the user must implement this
	${modelGlobal.name}(void);

	${modelGlobal.name}(const ${modelGlobal.name}&) = delete;
	${modelGlobal.name}& operator = (const ${modelGlobal.name}&) = delete;

	/// the user's requested members
	/// ... the user must implement these
#for (member <- modelGlobal.members)
		${nephrite("\n\t\t", member)}
#end

	/// alternative const char* interfaces
#for (member <- modelGlobal.members.filter(m => m.isInstanceOf[Model.MemberFunction] && m.asInstanceOf[Model.MemberFunction].arguments.exists(_.kind == Model.KindString)))
		${nephrite.sub("/const-char-method-wrappers")("\n\t\t", member)}
#end

	/// the ${modelGlobal.name} destructor
	/// ... the user must implement this
	~${modelGlobal.name}(void);

	/// magic method to load/store dynamic fields
	template<typename T>
	T& Stash(const pal_adler32::obj&);

	/// overload. assumes typeid(T).name() is acceptable
	template<typename T> T& Stash(void) { const static pal_adler32::obj hash = typeid(T).name(); return Stash<T>(hash); }

	/// locates the instance
	static ${modelGlobal.name}& get(duk_context*);
};
