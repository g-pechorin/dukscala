#import(peterlavalle.scad40.Model)
<%@ val modelMemberFunction: Model.MemberFunction %>
<%@ val modelModule: Model.Module %>
<%@ val modelGlobal: Model.Global %>
<%@ val nephrite: peterlavalle.scad40.Nephrite %>
#{
    val className = modelModule.name.replace(".", "::") + "::" + modelGlobal.name

    var arguments =
        modelMemberFunction.arguments.zipWithIndex.foldLeft("") {
            case (left, (next, idx)) =>
                left + ",\n\t\t" + (next.kind match {
                case Model.KindString =>
                    "scad40::duk_str(ctx, %d)"
                    .format(idx)

                case Model.KindDeclaration(Model.Script(name, _)) =>
                "scad40::duk_ptr<%s::%s>(ctx, %d)"
                    .format(modelModule.name.replace(".", "::"), name, idx)

                case Model.KindDeclaration(Model.Native(name, _)) =>
                "scad40::duk_ref<%s::%s>(ctx, %d)"
                    .format(modelModule.name.replace(".", "::"), name, idx)

                case Model.KindVoid =>
                    sys.error("No! How you get `void` args!?")

                case wat =>
                    wat.toString
                })
        }.replaceAll(",\n\t\t$", "").replaceAll("^,", "")
}#
scad40::push_selfie<${className}>(ctx, this${modelGlobal.name}, ${modelMemberFunction.arguments.size}, [](duk_context* ctx, ${className}* this${modelGlobal.name}) -> duk_ret_t {
#if (Model.KindVoid == modelMemberFunction.resultKind)
    thisDisk->${modelMemberFunction.name}(
#else
    auto result = thisDisk->${modelMemberFunction.name}(
#end ${arguments}
    );
#match (modelMemberFunction.resultKind)
#case(Model.KindVoid)
    return 0;
#case(Model.KindDeclaration(_))
    result.Push();
    return 1;
#otherwise
    return ???; ${modelMemberFunction.resultKind}
#end
});
duk_put_prop_string(ctx, idxBase, "${modelMemberFunction.name}");