#import(peterlavalle.scad40.Model)
<%@ val modelNative: Model.Native %>
<%@ val nephrite: peterlavalle.scad40.Nephrite %>
struct ${modelNative.name} : public scad40::_object
{
	/// the ${modelNative.name} constructor
	/// ... the user must implement this
	${modelNative.name}(void);

	${modelNative.name}(const ${modelNative.name}&) = delete;
	${modelNative.name}& operator= (const ${modelNative.name}&) = delete;

	/// the user's requested members
	/// the user must implement these
#for (member <- modelNative.members)
		${nephrite("\n\t\t", member).trim}
#end

	/// alternative const char* interfaces
#for (member <- modelNative.members.filter(m => m.isInstanceOf[Model.MemberFunction] && m.asInstanceOf[Model.MemberFunction].arguments.exists(_.kind == Model.KindString)))
		${nephrite.sub("/const-char-method-wrappers")("\n\t\t", member)}
#end

	/// the Reading destructor
	/// the user must implement this
	~${modelNative.name}(void);

	/// queries if the passed index is a ${modelNative.name} object
	static bool Is(duk_context* ctx, duk_idx_t idx);

	/// creates a new ${modelNative.name} object and returns a magical pointer to it
	static scad40::duk_ref${ "<" + modelNative.name + ">"} New(duk_context* ctx);

	/// pulls the the passed index into a ${modelNative.name} object
	/// ... if the passed index is not a ${modelNative.name} object - behaviour is undefined
	static scad40::duk_ref${ "<" + modelNative.name + ">"} To(duk_context* ctx, duk_idx_t idx);
};
