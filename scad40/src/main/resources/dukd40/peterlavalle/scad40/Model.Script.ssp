#import(peterlavalle.scad40.Model)
<%@ val modelScript: Model.Script %>
<%@ val nephrite: peterlavalle.scad40.Nephrite %>
// script C++ classes are really just wrappers to access the ECMAScript implementation
class ${modelScript.name}
{
	/// used for const-char wrapping
	duk_context* Host(void) { return reinterpret_cast${"<"}scad40::duk_ptr<${modelScript.name}>*>(this)->Host(); }
public:

	/// the user's requested members
#for (member <- modelScript.members)
		${nephrite("\n\t\t", member)}
#end

	/// alternative const char* interfaces
#for (member <- modelScript.members.filter(m => m.isInstanceOf[Model.MemberFunction] && m.asInstanceOf[Model.MemberFunction].arguments.exists(_.kind == Model.KindString)))
		${nephrite.sub("/const-char-method-wrappers")("\n\t\t", member)}
#end

	/// create an instance of a scripted class that extends this class
	static scad40::duk_ptr<${modelScript.name}> New(duk_context* ctx, const char* subclass);

	/// is the value at the stack index useable as an instance of this class
	static bool As(duk_context* ctx, duk_idx_t idx);

	/// pull whatever is at the stack index into C++
	static scad40::duk_ptr<${modelScript.name}> To(duk_context* ctx, duk_idx_t idx);
};
