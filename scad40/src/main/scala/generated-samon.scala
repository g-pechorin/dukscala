package peterlavalle {


	import peterlavalle.scad40.Model._
	class DukScaCC {
		def apply(writer: java.io.Writer, module: Module): Unit = {
			val namespace= module.name.replace(".", "::")
			writer.append("\n")
			writer.append("#pragma once").append("\n")
			writer.append("\n")
			writer.append("///").append("\n")
			writer.append("/// These classes are used to bridge-the-gap between Scala-JS and C++").append("\n")
			writer.append("/// ... they're not thread-safe but then ... neither is DukTape").append("\n")
			writer.append("/// ... all modules (should) use the same definition of them - so don't worry about namespace collisions").append("\n")
			writer.append("#ifndef _scad40_head").append("\n")
			writer.append("#define _scad40_head").append("\n")
			writer.append("\n")
			writer.append("#include <duktape.h>").append("\n")
			writer.append("\n")
			writer.append("#include \"pal_adler32.hpp\"").append("\n")
			writer.append("\n")
			writer.append("#include <array>").append("\n")
			writer.append("#include <string>").append("\n")
			writer.append("#include <iostream>").append("\n")
			writer.append("\n")
			writer.append("#include <assert.h>").append("\n")
			writer.append("#include <stdint.h>").append("\n")
			writer.append("\n")
			writer.append("#define scad40__pre_string (\"\\xFF\" \"scad40\")").append("\n")
			writer.append("#define scad40__pre_strlen (7)").append("\n")
			writer.append("\n")
			writer.append("namespace scad40").append("\n")
			writer.append("{").append("\n")
			writer.append("\t/// goofy wrapper to push member-like functions (so methods and accessors)").append("\n")
			writer.append("\t/// ... should I call it \"push_method?\" or \"push_member?\"").append("\n")
			writer.append("\ttemplate<typename T>").append("\n")
			writer.append("\tvoid push_selfie(duk_context* ctx, T* self, duk_idx_t nargs, duk_ret_t(*code)(duk_context*, T*));").append("\n")
			writer.append("\n")
			writer.append("\t/// checks if the table at {idx} has a key named {key} and").append("\n")
			writer.append("\t/// @returns false if the value is undefined_or_null.").append("\n")
			writer.append("\t/// restores the stack").append("\n")
			writer.append("\tbool has_prop(duk_context* ctx, const duk_idx_t idx, const char* key);").append("\n")
			writer.append("\n")
			writer.append("\t/// base object for things that play with with pointers").append("\n")
			writer.append("\t/// don't look to closesly at the guts").append("\n")
			writer.append("\t/// used for both the \"_handle\" subclasses and the generated derrived types").append("\n")
			writer.append("\tclass _object").append("\n")
			writer.append("\t{").append("\n")
			writer.append("\t\t/// magical pointer to the object's hosting context").append("\n")
			writer.append("\t\t/// ... it will/should be set before construction (did I mention `magic`)").append("\n")
			writer.append("\t\tduk_context* _ctx;").append("\n")
			writer.append("\n")
			writer.append("\t\tfriend struct _handle;").append("\n")
			writer.append("\n")
			writer.append("\t\t/// usercode should never actually call this (trust me)").append("\n")
			writer.append("\t\t_object(duk_context* ctx) :").append("\n")
			writer.append("\t\t\t_ctx(ctx)").append("\n")
			writer.append("\t\t{").append("\n")
			writer.append("\t\t\tassert(nullptr != _ctx);").append("\n")
			writer.append("\t\t}").append("\n")
			writer.append("\n")
			writer.append("\tprotected:").append("\n")
			writer.append("\t\t/// copy operators are hidden since they should only be used by _handle").append("\n")
			writer.append("\t\t_object(const _object& other) :").append("\n")
			writer.append("\t\t\t_object(other._ctx)").append("\n")
			writer.append("\t\t{").append("\n")
			writer.append("\t\t}").append("\n")
			writer.append("\n")
			writer.append("\t\t_object& operator=(const _object& other)").append("\n")
			writer.append("\t\t{").append("\n")
			writer.append("\t\t\tassert(_ctx == other._ctx);").append("\n")
			writer.append("\t\t\treturn *this;").append("\n")
			writer.append("\t\t}").append("\n")
			writer.append("\n")
			writer.append("\t\t/// usercode will laways use this method to invoke the parent").append("\n")
			writer.append("\t\t_object(void)").append("\n")
			writer.append("\t\t{").append("\n")
			writer.append("\t\t\t/// this will/should have been magically setup").append("\n")
			writer.append("\t\t\tassert(nullptr != _ctx);").append("\n")
			writer.append("\t\t}").append("\n")
			writer.append("\n")
			writer.append("\tpublic:").append("\n")
			writer.append("\t\tduk_context* Host(void) const").append("\n")
			writer.append("\t\t{").append("\n")
			writer.append("\t\t\treturn _ctx;").append("\n")
			writer.append("\t\t}").append("\n")
			writer.append("\t};").append("\n")
			writer.append("\n")
			writer.append("\t/// this refers to a thing in script-land but is not itself a thing").append("\n")
			writer.append("\t/// it's used for the duk_(ref|str|ptr) classes").append("\n")
			writer.append("\t/// Google calls it a handle - https://developers.google.com/v8/embed?hl=en").append("\n")
			writer.append("\tstruct _handle : scad40::_object").append("\n")
			writer.append("\t{").append("\n")
			writer.append("\t\t/// pushes (a reference to) the value onto the stack (or maybe null if the value is null)").append("\n")
			writer.append("\t\tvoid Push(void) const").append("\n")
			writer.append("\t\t{").append("\n")
			writer.append("\t\t\tduk_push_global_stash(_ctx);").append("\n")
			writer.append("\t\t\t// stack -> ... ; [stash] ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\t// because we're using the pointer as a GUID this is acceptable").append("\n")
			writer.append("\t\t\tduk_push_pointer(_ctx, const_cast<scad40::_handle*>(this));").append("\n")
			writer.append("\t\t\t// stack -> ... ; [stash] ; *this ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tduk_get_prop(_ctx, -2);").append("\n")
			writer.append("\t\t\t// stack -> ... ; [stash] ; value ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tduk_remove(_ctx, -2);").append("\n")
			writer.append("\t\t\t// stack -> ... ; value ;").append("\n")
			writer.append("\t\t}").append("\n")
			writer.append("\n")
			writer.append("\t\tbool IsNull(void) const").append("\n")
			writer.append("\t\t{").append("\n")
			writer.append("\t\t\t// stack -> ... ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tduk_push_global_stash(Host());").append("\n")
			writer.append("\t\t\t// stack -> ... ; [global stash] ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tduk_push_pointer(_ctx, const_cast<scad40::_handle*>(this));").append("\n")
			writer.append("\t\t\t// stack -> ... ; [global stash] ; *this ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tduk_get_prop(Host(), -2);").append("\n")
			writer.append("\t\t\t// stack -> ... ; [global stash] ; value ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tconst bool result = duk_is_null_or_undefined(Host(), -1) ? true : false;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tduk_pop_2(Host());").append("\n")
			writer.append("\t\t\t// stack -> ... ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\treturn result;").append("\n")
			writer.append("\t\t}").append("\n")
			writer.append("\n")
			writer.append("\tprotected:").append("\n")
			writer.append("\n")
			writer.append("\t\t/// making this protected approaximates an abstract class without introducting method-tables").append("\n")
			writer.append("\t\t/// ... introducting method-tables would kill us in evil little ways").append("\n")
			writer.append("\t\t_handle(duk_context* ctx) : scad40::_object(ctx) { }").append("\n")
			writer.append("\n")
			writer.append("\t\t/// partially expose the copy constructor to allow subclasses copy instances").append("\n")
			writer.append("\t\t_handle(const scad40::_handle& that) : scad40::_object(that)").append("\n")
			writer.append("\t\t{").append("\n")
			writer.append("\t\t\tduk_push_global_stash(_ctx);").append("\n")
			writer.append("\t\t\t// stack -> ... ; [stash] ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tduk_push_pointer(_ctx, this);").append("\n")
			writer.append("\t\t\t// stack -> ... ; [stash] ; *this ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tduk_push_pointer(_ctx, const_cast<scad40::_handle*>(&that));").append("\n")
			writer.append("\t\t\t// stack -> ... ; [stash] ; *this ; *that ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tduk_get_prop(_ctx, -3);").append("\n")
			writer.append("\t\t\t// stack -> ... ; [stash] ; *this ; value ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tduk_put_prop(_ctx, -3);").append("\n")
			writer.append("\t\t\t// stack -> ... ; [stash] ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tduk_pop(_ctx);").append("\n")
			writer.append("\t\t}").append("\n")
			writer.append("\n")
			writer.append("\t\t/// partially expose the copy operator to allow subclasses copy instances").append("\n")
			writer.append("\t\t_handle& operator=(const scad40::_handle& that)").append("\n")
			writer.append("\t\t{").append("\n")
			writer.append("\t\t\tassert(_ctx == that._ctx);").append("\n")
			writer.append("\n")
			writer.append("\t\t\t// stack -> ... ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tduk_push_global_stash(_ctx);").append("\n")
			writer.append("\t\t\t// stack -> ... ; [stash] ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tduk_push_pointer(_ctx, const_cast<scad40::_handle*>(this));").append("\n")
			writer.append("\t\t\t// stack -> ... ; [stash] ; *this ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tduk_push_pointer(_ctx, const_cast<scad40::_handle*>(&that));").append("\n")
			writer.append("\t\t\t// stack -> ... ; [stash] ; *this ; *that ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tduk_get_prop(_ctx, -3);").append("\n")
			writer.append("\t\t\t// stack -> ... ; [stash] ; *this ; value ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tduk_put_prop(_ctx, -3);").append("\n")
			writer.append("\t\t\t// stack -> ... ; [stash] ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tduk_pop(_ctx);").append("\n")
			writer.append("\t\t\t// stack -> ... ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\treturn *this;").append("\n")
			writer.append("\t\t}").append("\n")
			writer.append("\n")
			writer.append("\t\t~_handle(void)").append("\n")
			writer.append("\t\t{").append("\n")
			writer.append("\t\t\tif (nullptr == _ctx)").append("\n")
			writer.append("\t\t\t{").append("\n")
			writer.append("\t\t\t\treturn;").append("\n")
			writer.append("\t\t\t}").append("\n")
			writer.append("\n")
			writer.append("\t\t\t// stack -> ... ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tduk_push_global_stash(_ctx);").append("\n")
			writer.append("\t\t\t// stack -> ... ; [global stash] ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tduk_push_pointer(_ctx, this);").append("\n")
			writer.append("\t\t\t// stack -> ... ; [global stash] ; *this ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tduk_del_prop(_ctx, -2);").append("\n")
			writer.append("\t\t\t// stack -> ... ; [global stash] ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tduk_pop(_ctx);").append("\n")
			writer.append("\t\t\t// stack -> ... ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\t_ctx = nullptr;").append("\n")
			writer.append("\t\t}").append("\n")
			writer.append("\t};").append("\n")
			writer.append("\n")
			writer.append("\t/// this allows manipulating a pure-script object from C++ using a predefined interface").append("\n")
			writer.append("\t/// ironically ; less sophiticated than the ref").append("\n")
			writer.append("\ttemplate<typename T>").append("\n")
			writer.append("\tstruct duk_ptr : public scad40::_handle").append("\n")
			writer.append("\t{").append("\n")
			writer.append("\t\tduk_ptr(duk_context* ctx, duk_idx_t idx) : scad40::_handle(ctx)").append("\n")
			writer.append("\t\t{").append("\n")
			writer.append("\t\t\tidx = duk_normalize_index(ctx, idx);").append("\n")
			writer.append("\t\t\tassert(T::As(ctx, idx));").append("\n")
			writer.append("\n")
			writer.append("\t\t\t// stack -> ... ; idx ... ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tduk_push_global_stash(ctx);").append("\n")
			writer.append("\t\t\t// stack -> ... ; idx ... ; [stash] ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tduk_push_pointer(ctx, this);").append("\n")
			writer.append("\t\t\t// stack -> ... ; idx ... ; [stash] ; *this ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tduk_dup(ctx, idx);").append("\n")
			writer.append("\t\t\t// stack -> ... ; idx ... ; [stash] ; *this ; [val] ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tduk_put_prop(ctx, -3);").append("\n")
			writer.append("\t\t\t// stack -> ... ; idx ... ; [stash] ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tduk_pop(ctx);").append("\n")
			writer.append("\t\t\t// stack -> ... ; idx ... ;").append("\n")
			writer.append("\t\t}").append("\n")
			writer.append("\n")
			writer.append("\t\tT* operator->(void) { return reinterpret_cast<T*>(this); }").append("\n")
			writer.append("\n")
			writer.append("\t\tconst T* operator->(void) const { return reinterpret_cast<T*>(this); }").append("\n")
			writer.append("\t};").append("\n")
			writer.append("\n")
			writer.append("\t/// baseclass used for _handle things with a native pointer").append("\n")
			writer.append("\t/// ... which is really just an optimization for strings and native objects ...").append("\n")
			writer.append("\ttemplate<typename T>").append("\n")
			writer.append("\tstruct _native : scad40::_handle").append("\n")
			writer.append("\t{").append("\n")
			writer.append("\n")
			writer.append("\tprotected:").append("\n")
			writer.append("\t\tT* _pointer;").append("\n")
			writer.append("\t\t_native(duk_context* ctx) : scad40::_handle(ctx) { }").append("\n")
			writer.append("\n")
			writer.append("\tpublic:").append("\n")
			writer.append("\t\tT* operator->(void) { return _pointer; }").append("\n")
			writer.append("\t\tconst T* operator->(void) const { return _pointer; }").append("\n")
			writer.append("\t};").append("\n")
			writer.append("\n")
			writer.append("\t/// holds a ref to a C++ object built for duktape using magic").append("\n")
			writer.append("\t/// the pointer is updated on copy so that you get a bit faster access to it").append("\n")
			writer.append("\ttemplate<typename T>").append("\n")
			writer.append("\tstruct duk_native : public scad40::_native<T>").append("\n")
			writer.append("\t{").append("\n")
			writer.append("\tpublic:").append("\n")
			writer.append("\n")
			writer.append("\t\t/// grab an instance from the stack. fails violently if types are wrong").append("\n")
			writer.append("\t\tduk_native(duk_context* ctx, duk_idx_t idx) :").append("\n")
			writer.append("\t\t\tscad40::_native<T>(ctx)").append("\n")
			writer.append("\t\t{").append("\n")
			writer.append("\t\t\tidx = duk_normalize_index(ctx, idx);").append("\n")
			writer.append("\t\t\tassert(T::Is(ctx, idx));").append("\n")
			writer.append("\t\t\t// stack -> ... ; [T] ; ... ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tduk_get_prop_string(ctx, idx, \"\\xFF\" \"*\");").append("\n")
			writer.append("\t\t\t// stack -> ... ; [T] ; ... ; T* ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\t_pointer = (T*)duk_to_pointer(ctx, -1);").append("\n")
			writer.append("\n")
			writer.append("\t\t\tduk_pop(ctx);").append("\n")
			writer.append("\t\t\t// stack -> ... ; [T] ; ... ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tduk_push_global_stash(ctx);").append("\n")
			writer.append("\t\t\t// stack -> ... ; [T] ; ... ; [stash] ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tduk_push_pointer(ctx, this);").append("\n")
			writer.append("\t\t\t// stack -> ... ; [T] ; ... ; [stash] ; *this ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tduk_dup(ctx, idx);").append("\n")
			writer.append("\t\t\t// stack -> ... ; [T] ; ... ; [stash] ; *this ; [T] ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tduk_put_prop(ctx, -3);").append("\n")
			writer.append("\t\t\t// stack -> ... ; [T] ; ... ; [stash] ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tduk_pop(ctx);").append("\n")
			writer.append("\t\t\t// stack -> ... ; [T] ; ... ;").append("\n")
			writer.append("\t\t}").append("\n")
			writer.append("\n")
			writer.append("\t};").append("\n")
			writer.append("\n")
			writer.append("\t/// holds a ref to a duktape string using magic").append("\n")
			writer.append("\t/// as much as possible I stick strings into duktape and try not to think too hard about them").append("\n")
			writer.append("\t/// the pointer is updated on copy so that you get a bit faster access to it").append("\n")
			writer.append("\tclass duk_string : public scad40::_native<const char>").append("\n")
			writer.append("\t{").append("\n")
			writer.append("\tpublic:").append("\n")
			writer.append("\t\toperator const char* (void) const { return _pointer; }").append("\n")
			writer.append("\t\toperator std::string (void) const { return _pointer; }").append("\n")
			writer.append("\n")
			writer.append("\t\t/// create an instance and set it to point to the passed string").append("\n")
			writer.append("\t\tduk_string(duk_context* ctx, const char* str = nullptr) :").append("\n")
			writer.append("\t\t\tscad40::_native<const char>(ctx)").append("\n")
			writer.append("\t\t{").append("\n")
			writer.append("\t\t\tduk_push_global_stash(ctx);").append("\n")
			writer.append("\t\t\t// stack -> ... ; [stash] ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tduk_push_pointer(ctx, this);").append("\n")
			writer.append("\t\t\t// stack -> ... ; [stash] ; *this ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tif (nullptr == str)").append("\n")
			writer.append("\t\t\t{").append("\n")
			writer.append("\t\t\t\tduk_push_undefined(ctx);").append("\n")
			writer.append("\t\t\t\t_pointer = nullptr;").append("\n")
			writer.append("\t\t\t}").append("\n")
			writer.append("\t\t\telse").append("\n")
			writer.append("\t\t\t{").append("\n")
			writer.append("\t\t\t\t_pointer = duk_push_string(ctx, str);").append("\n")
			writer.append("\t\t\t}").append("\n")
			writer.append("\t\t\t// stack -> ... ; [stash] ; *this ; \"_pointer\" ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tduk_put_prop(ctx, -3);").append("\n")
			writer.append("\t\t\t// stack -> ... ; [stash] ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tduk_pop(ctx);").append("\n")
			writer.append("\t\t\t// stack -> ... ;").append("\n")
			writer.append("\t\t}").append("\n")
			writer.append("\n")
			writer.append("\t\t/// create an instance and set it to point to the passed string").append("\n")
			writer.append("\t\tduk_string(duk_context* ctx, const std::string&);").append("\n")
			writer.append("\n")
			writer.append("\t\t/// grab an instance from the stack").append("\n")
			writer.append("\t\tduk_string(duk_context* ctx, duk_idx_t idx) :").append("\n")
			writer.append("\t\t\tscad40::_native<const char>(ctx)").append("\n")
			writer.append("\t\t{").append("\n")
			writer.append("\t\t\tassert(duk_is_string(ctx, idx));").append("\n")
			writer.append("\n")
			writer.append("\t\t\tidx = duk_normalize_index(ctx, idx);").append("\n")
			writer.append("\n")
			writer.append("\t\t\t// stack -> ... ; \"val\" ; ... ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tauto stash = duk_get_top(ctx);").append("\n")
			writer.append("\t\t\tduk_push_global_stash(ctx);").append("\n")
			writer.append("\t\t\t// stack -> ... ; \"val\" ; ... ; [stash] ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tduk_push_pointer(ctx, this);").append("\n")
			writer.append("\t\t\t// stack -> ... ; \"val\" ; ... ; [stash] ; *this ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\t_pointer = duk_is_null_or_undefined(ctx, idx) ? nullptr : duk_to_string(ctx, idx);").append("\n")
			writer.append("\t\t\tif (!_pointer)").append("\n")
			writer.append("\t\t\t\tduk_push_undefined(ctx);").append("\n")
			writer.append("\t\t\telse").append("\n")
			writer.append("\t\t\t\tduk_dup(ctx, idx);").append("\n")
			writer.append("\t\t\t// stack -> ... ; \"val\" ; ... ; [stash] ; *this ; \"val\" ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tduk_put_prop(ctx, stash);").append("\n")
			writer.append("\t\t\t// stack -> ... ; \"val\" ; ... ; [stash] ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tduk_pop(ctx);").append("\n")
			writer.append("\t\t\t// stack -> ... ; \"val\" ; ... ;").append("\n")
			writer.append("\t\t}").append("\n")
			writer.append("\n")
			writer.append("\t\tduk_string& operator= (const char* value)").append("\n")
			writer.append("\t\t{").append("\n")
			writer.append("\n")
			writer.append("\t\t\t// stack -> ... ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tauto stash = duk_get_top(Host());").append("\n")
			writer.append("\t\t\tduk_push_global_stash(Host());").append("\n")
			writer.append("\t\t\t// stack -> ... ; [stash] ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tduk_push_pointer(Host(), this);").append("\n")
			writer.append("\t\t\t// stack -> ... ; [stash] ; *this ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tduk_push_string(Host(), value);").append("\n")
			writer.append("\t\t\t// stack -> ... ; [stash] ; *this ; \"value\" ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tduk_put_prop(Host(), stash);").append("\n")
			writer.append("\t\t\t// stack -> ... ; [stash] ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tduk_pop(Host());").append("\n")
			writer.append("\t\t\t// stack -> ... ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\treturn *this;").append("\n")
			writer.append("\t\t}").append("\n")
			writer.append("\t\tduk_string& operator= (const std::string& other)\t{ return *this = other.c_str(); }").append("\n")
			writer.append("\n")
			writer.append("\t\tbool operator== (const char* other) const\t\t\t{ return 0 == strcmp(_pointer, other); }").append("\n")
			writer.append("\t\tbool operator== (const std::string& other) const\t{ return 0 == strcmp(_pointer, other.c_str()); }").append("\n")
			writer.append("\t\tbool operator== (const duk_string& other) const\t\t{ return 0 == strcmp(_pointer, other._pointer); }").append("\n")
			writer.append("\t};").append("\n")
			writer.append("\n")
			writer.append("\t/// tools to pick at DukTape's global table like we're in script-land").append("\n")
			writer.append("\tnamespace env").append("\n")
			writer.append("\t{").append("\n")
			writer.append("\t\t/// puts whatever is on top of the stack somewhere into the global namespace").append("\n")
			writer.append("\t\t/// happily splits up names with '.' in them - otherwise it'd redumdant").append("\n")
			writer.append("\t\t/// creates whatever tables it needs to along the way").append("\n")
			writer.append("\t\t/// throws an error if it finds a pre-existing value").append("\n")
			writer.append("\t\tvoid assign(duk_context* ctx, const char* key);").append("\n")
			writer.append("\n")
			writer.append("\t\t/// checks the global namespace for a non null_or_undefined value at path").append("\n")
			writer.append("\t\tbool exists(duk_context* ctx, const char* path);").append("\n")
			writer.append("\n")
			writer.append("\t\t/// reads something from the global namespace and pushes it on the stack").append("\n")
			writer.append("\t\t/// happily splits up names with '.' in them - otherwise it'd redumdant").append("\n")
			writer.append("\t\t/// happily pushes undefined if there's no value there").append("\n")
			writer.append("\t\tvoid lookup(duk_context* ctx, const char* binding);").append("\n")
			writer.append("\n")
			writer.append("\t\t/// drops the value at key from the global namespace").append("\n")
			writer.append("\t\t/// happily splits up names with '.' in them - otherwise it'd redumdant").append("\n")
			writer.append("\t\t/// leaves empty containers et-al in place").append("\n")
			writer.append("\t\t/// bails if there's no key").append("\n")
			writer.append("\t\t/// really-really calls the delete function (instead of assigning null/undef to it)").append("\n")
			writer.append("\t\t/// throws an error iff nothing exists there").append("\n")
			writer.append("\t\tvoid remove(duk_context* ctx, const char* path);").append("\n")
			writer.append("\t};").append("\n")
			writer.append("};").append("\n")
			writer.append("#endif // ... okay - that's the end of predef").append("\n")
			writer.append("\n")
			(module.name.split("\\.")).foreach {
				case namespace =>
					writer.append("namespace ").append(namespace).append(" {").append("\n")
			}
			writer.append("\n")
			writer.append("meat goes here").append("\n")
			writer.append("\n")
			(module.name.split("\\.")).foreach {
				case namespace =>
					writer.append("}").append("\n")
			}
			writer.append("\n")
			writer.append("#ifndef _scad40_tail").append("\n")
			writer.append("#define _scad40_tail").append("\n")
			writer.append("#pragma region \"scad40 and scad40::env\"").append("\n")
			writer.append("inline bool scad40::has_prop(duk_context* ctx, const duk_idx_t idx, const char* key)").append("\n")
			writer.append("{").append("\n")
			writer.append("\t// stack -> .. idx ... ;").append("\n")
			writer.append("\n")
			writer.append("\tduk_get_prop_string(ctx, idx, key);").append("\n")
			writer.append("\t// stack -> .. idx ... ; value ;").append("\n")
			writer.append("\n")
			writer.append("\tconst bool result = duk_is_null_or_undefined(ctx, -1) ? false : true;").append("\n")
			writer.append("\n")
			writer.append("\tduk_pop(ctx);").append("\n")
			writer.append("\t// stack -> .. idx ... ;").append("\n")
			writer.append("\n")
			writer.append("\treturn result;").append("\n")
			writer.append("}").append("\n")
			writer.append("\n")
			writer.append("template<typename T>").append("\n")
			writer.append("inline void scad40::push_selfie<T>(duk_context* ctx, T* self, duk_idx_t nargs, duk_ret_t(*code)(duk_context*, T*))").append("\n")
			writer.append("{").append("\n")
			writer.append("\tduk_push_c_function(ctx, [](duk_context* ctx) -> duk_ret_t {").append("\n")
			writer.append("\t\tduk_push_current_function(ctx);").append("\n")
			writer.append("\t\tduk_get_prop_string(ctx, -1, \"\\xFF\" \"self\");").append("\n")
			writer.append("\t\tduk_get_prop_string(ctx, -2, \"\\xFF\" \"code\");").append("\n")
			writer.append("\t\tauto self = (T*)duk_to_pointer(ctx, -2);").append("\n")
			writer.append("\t\tauto code = (duk_ret_t(*)(duk_context*, T*))duk_to_pointer(ctx, -1);").append("\n")
			writer.append("\t\tduk_pop_3(ctx);").append("\n")
			writer.append("\t\treturn code(ctx, self);").append("\n")
			writer.append("\t}, nargs);").append("\n")
			writer.append("\tduk_push_pointer(ctx, self);").append("\n")
			writer.append("\tduk_put_prop_string(ctx, -2, \"\\xFF\" \"self\");").append("\n")
			writer.append("\tduk_push_pointer(ctx, code);").append("\n")
			writer.append("\tduk_put_prop_string(ctx, -2, \"\\xFF\" \"code\");").append("\n")
			writer.append("}").append("\n")
			writer.append("\n")
			writer.append("inline void scad40::env::assign(duk_context* ctx, const char* key)").append("\n")
			writer.append("{").append("\n")
			writer.append("\tsize_t idx = 0, len = 0;").append("\n")
			writer.append("\n")
			writer.append("\tconst auto val = duk_get_top(ctx);").append("\n")
			writer.append("\t// stack -> ... ; val ;").append("\n")
			writer.append("\n")
			writer.append("\tduk_push_global_object(ctx);").append("\n")
			writer.append("\t// stack -> ... ; val ; [global host] ;").append("\n")
			writer.append("\n")
			writer.append("\twhile (key[idx + len])").append("\n")
			writer.append("\t{").append("\n")
			writer.append("\t\t// stack -> ... ; val ; [host] ;").append("\n")
			writer.append("\n")
			writer.append("\t\tif ('.' != key[idx + len])").append("\n")
			writer.append("\t\t{").append("\n")
			writer.append("\t\t\t++len;").append("\n")
			writer.append("\t\t}").append("\n")
			writer.append("\t\telse").append("\n")
			writer.append("\t\t{").append("\n")
			writer.append("\t\t\tduk_push_lstring(ctx, key + idx, len);").append("\n")
			writer.append("\t\t\t// stack -> ... ; val ; [outer host] ; \"key\" ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tduk_get_prop(ctx, -2);").append("\n")
			writer.append("\t\t\t// stack -> ... ; val ; [outer host] ; ?[inner host]? ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tif (duk_is_null_or_undefined(ctx, -1))").append("\n")
			writer.append("\t\t\t{").append("\n")
			writer.append("\t\t\t\t// stack -> ... ; val ; [outer host] ; <undefined> ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\t\tduk_pop(ctx);").append("\n")
			writer.append("\t\t\t\t// stack -> ... ; val ; [outer host] ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\t\tduk_push_object(ctx);").append("\n")
			writer.append("\t\t\t\t// stack -> ... ; val ; [outer host] ; [inner host] ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\t\tduk_push_lstring(ctx, key + idx, len);").append("\n")
			writer.append("\t\t\t\t// stack -> ... ; val ; [outer host] ; [inner host] ; \"key\" ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\t\tduk_dup(ctx, -2);").append("\n")
			writer.append("\t\t\t\t// stack -> ... ; val ; [outer host] ; [inner host] ; \"key\" ; [inner host] ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\t\tduk_put_prop(ctx, -4);").append("\n")
			writer.append("\t\t\t\t// stack -> ... ; val ; [outer host] ; [inner host] ;").append("\n")
			writer.append("\t\t\t}").append("\n")
			writer.append("\t\t\telse if (!duk_is_object(ctx, -1))").append("\n")
			writer.append("\t\t\t{").append("\n")
			writer.append("\t\t\t\tduk_push_lstring(ctx, key, idx + len);").append("\n")
			writer.append("\t\t\t\tduk_error(ctx, 314, \"Collision `%s`\", duk_to_string(ctx, -1));").append("\n")
			writer.append("\t\t\t\treturn;").append("\n")
			writer.append("\t\t\t}").append("\n")
			writer.append("\n")
			writer.append("\t\t\t// stack -> ... ; val ; [outer host] ; [inner host] ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tduk_remove(ctx, -2);").append("\n")
			writer.append("\t\t\t// stack -> ... ; val ; [inner host] ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tidx = idx + len + 1;").append("\n")
			writer.append("\t\t\tlen = 0;").append("\n")
			writer.append("\t\t}").append("\n")
			writer.append("\t}").append("\n")
			writer.append("\n")
			writer.append("\t// stack -> ... ; val ; [host] ;").append("\n")
			writer.append("\n")
			writer.append("\tduk_push_lstring(ctx, key + idx, len);").append("\n")
			writer.append("\t// stack -> ... ; val ; [host] ; \"key\" ;").append("\n")
			writer.append("\n")
			writer.append("\tduk_dup(ctx, -3);").append("\n")
			writer.append("\t// stack -> ... ; val ; [host] ; \"key\" ; val ;").append("\n")
			writer.append("\n")
			writer.append("\tduk_remove(ctx, -4);").append("\n")
			writer.append("\t// stack -> ... ; [host] ; \"key\" ; val ;").append("\n")
			writer.append("\n")
			writer.append("\tduk_put_prop(ctx, -3);").append("\n")
			writer.append("\t// stack -> ... ; [host] ;").append("\n")
			writer.append("\n")
			writer.append("\tduk_pop(ctx);").append("\n")
			writer.append("\t// stack -> ... ;").append("\n")
			writer.append("\n")
			writer.append("}").append("\n")
			writer.append("\n")
			writer.append("inline bool scad40::env::exists(duk_context* ctx, const char* path)").append("\n")
			writer.append("{").append("\n")
			writer.append("\t// stack -> .... base .. ;").append("\n")
			writer.append("\n")
			writer.append("\tscad40::env::lookup(ctx, path);").append("\n")
			writer.append("\t// stack -> .... base .. ; ??? ;").append("\n")
			writer.append("\n")
			writer.append("\tconst auto result = duk_is_null_or_undefined(ctx, -1) ? false : true;").append("\n")
			writer.append("\n")
			writer.append("\tduk_pop(ctx);").append("\n")
			writer.append("\t// stack -> .... base .. ;").append("\n")
			writer.append("\n")
			writer.append("\treturn result;").append("\n")
			writer.append("}").append("\n")
			writer.append("\n")
			writer.append("inline void scad40::env::lookup(duk_context* ctx, const char* binding)").append("\n")
			writer.append("{").append("\n")
			writer.append("\tsize_t idx = 0, len = 0;").append("\n")
			writer.append("\n")
			writer.append("\tauto base = duk_get_top(ctx);").append("\n")
			writer.append("\t// stack -> .... base .. ;").append("\n")
			writer.append("\n")
			writer.append("\tduk_push_global_object(ctx);").append("\n")
			writer.append("\t// stack -> .... base .. ; [global host] ;").append("\n")
			writer.append("\n")
			writer.append("\twhile (binding[idx + len])").append("\n")
			writer.append("\t{").append("\n")
			writer.append("\t\t// stack -> .... base .. ; [host] ;").append("\n")
			writer.append("\t\tif ('.' != binding[idx + len])").append("\n")
			writer.append("\t\t{").append("\n")
			writer.append("\t\t\t++len;").append("\n")
			writer.append("\t\t}").append("\n")
			writer.append("\t\telse").append("\n")
			writer.append("\t\t{").append("\n")
			writer.append("\t\t\tduk_push_lstring(ctx, binding + idx, len);").append("\n")
			writer.append("\t\t\t// stack -> .... base .. ; [outer host] ; \"key\" ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tassert((2 + base) == duk_get_top(ctx));").append("\n")
			writer.append("\t\t\tduk_get_prop(ctx, -2);").append("\n")
			writer.append("\t\t\t// stack -> .... base .. ; [outer host] ; ?[inner host]? ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tif (duk_is_null_or_undefined(ctx, -1))").append("\n")
			writer.append("\t\t\t{").append("\n")
			writer.append("\t\t\t\tduk_pop_2(ctx);").append("\n")
			writer.append("\t\t\t\t// stack -> .... base .. ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\t\tassert(base == duk_get_top(ctx));").append("\n")
			writer.append("\t\t\t\tduk_push_undefined(ctx);").append("\n")
			writer.append("\t\t\t\t// stack -> .... base .. ; <undefined> ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\t\treturn;").append("\n")
			writer.append("\t\t\t}").append("\n")
			writer.append("\n")
			writer.append("\t\t\t// stack -> .... base .. ; [outer host] ; [inner host] ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tduk_remove(ctx, base);").append("\n")
			writer.append("\t\t\t// stack -> .... base .. ; [inner host] ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tidx = idx + len + 1;").append("\n")
			writer.append("\t\t\tlen = 0;").append("\n")
			writer.append("\t\t}").append("\n")
			writer.append("\t}").append("\n")
			writer.append("\n")
			writer.append("\tassert(0 != len);").append("\n")
			writer.append("\t// stack -> .... base .. ; [host] ;").append("\n")
			writer.append("\n")
			writer.append("\tduk_get_prop_string(ctx, -1, binding + idx);").append("\n")
			writer.append("\t// stack -> .... base .. ; [host] ; val ;").append("\n")
			writer.append("\n")
			writer.append("\tduk_remove(ctx, -2);").append("\n")
			writer.append("\t// stack -> .... base .. ; val ;").append("\n")
			writer.append("}").append("\n")
			writer.append("\n")
			writer.append("inline void scad40::env::remove(duk_context* ctx, const char* binding)").append("\n")
			writer.append("{").append("\n")
			writer.append("\tsize_t idx = 0, len = 0;").append("\n")
			writer.append("\n")
			writer.append("\tauto base = duk_get_top(ctx);").append("\n")
			writer.append("\t// stack -> .... base .. ;").append("\n")
			writer.append("\n")
			writer.append("\tduk_push_global_object(ctx);").append("\n")
			writer.append("\t// stack -> .... base .. ; [global host] ;").append("\n")
			writer.append("\n")
			writer.append("\twhile (binding[idx + len])").append("\n")
			writer.append("\t{").append("\n")
			writer.append("\t\t// stack -> .... base .. ; [host] ;").append("\n")
			writer.append("\t\tif ('.' != binding[idx + len])").append("\n")
			writer.append("\t\t{").append("\n")
			writer.append("\t\t\t++len;").append("\n")
			writer.append("\t\t}").append("\n")
			writer.append("\t\telse").append("\n")
			writer.append("\t\t{").append("\n")
			writer.append("\t\t\tconst char* key = duk_push_lstring(ctx, binding + idx, len);").append("\n")
			writer.append("\t\t\t// stack -> .... base .. ; [outer host] ; \"key\" ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tassert((2 + base) == duk_get_top(ctx));").append("\n")
			writer.append("\t\t\tduk_get_prop(ctx, -2);").append("\n")
			writer.append("\t\t\t// stack -> .... base .. ; [outer host] ; ?[inner host]? ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tif (duk_is_null_or_undefined(ctx, -1))").append("\n")
			writer.append("\t\t\t{").append("\n")
			writer.append("\t\t\t\tduk_pop_2(ctx);").append("\n")
			writer.append("\t\t\t\t// stack -> .... base .. ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\t\treturn;").append("\n")
			writer.append("\t\t\t}").append("\n")
			writer.append("\n")
			writer.append("\t\t\t// stack -> .... base .. ; [outer host] ; [inner host] ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tduk_remove(ctx, base);").append("\n")
			writer.append("\t\t\t// stack -> .... base .. ; [inner host] ;").append("\n")
			writer.append("\n")
			writer.append("\t\t\tidx = idx + len + 1;").append("\n")
			writer.append("\t\t\tlen = 0;").append("\n")
			writer.append("\t\t}").append("\n")
			writer.append("\t}").append("\n")
			writer.append("\n")
			writer.append("\tassert(0 != len);").append("\n")
			writer.append("\tassert(0 == binding[idx + len]);").append("\n")
			writer.append("\tassert((base + 1) == duk_get_top(ctx));").append("\n")
			writer.append("\t// stack -> .... base .. ; [host] ;").append("\n")
			writer.append("\n")
			writer.append("\tduk_del_prop_string(ctx, -1, binding + idx);").append("\n")
			writer.append("\t// stack -> .... base .. ; [host] ;").append("\n")
			writer.append("\n")
			writer.append("\tduk_pop(ctx);").append("\n")
			writer.append("\t// stack -> .... base .. ;").append("\n")
			writer.append("}").append("\n")
			writer.append("#pragma endregion").append("\n")
			writer.append("\n")
			writer.append("inline std::ostream& operator<<(std::ostream& ostream, const scad40::duk_string& string)").append("\n")
			writer.append("{").append("\n")
			writer.append("\treturn ostream << static_cast<const char*>(string);").append("\n")
			writer.append("}").append("\n")
			writer.append("#endif // ... okay - that's the end of predef").append("\n")
			writer.append("\n")
			(module.contents).foreach {
				case script: Script =>
					writer.append("???").append("\n")
					writer.append("\n")
				case native: Native =>
					writer.append("???").append("\n")
					writer.append("\n")
				case Global(name, _) =>
					writer.append("#pragma region \"global ").append(name).append("\"").append("\n")
					writer.append("inline ").append(namespace).append("::").append(name).append("& ").append(namespace).append("::").append(name).append("::get(duk_context* ctx)").append("\n")
					writer.append("{").append("\n")
					writer.append("\tauto base = duk_get_top(ctx);").append("\n")
					writer.append("\n")
					writer.append("\t// stack -> .... base .. ;").append("\n")
					writer.append("\n")
					writer.append("\tscad40::env::lookup(ctx, \"peterlavalle.diskio.").append(name).append("\");").append("\n")
					writer.append("\t// stack -> .... base .. ; [").append(name).append("] ;").append("\n")
					writer.append("\n")
					writer.append("\tduk_get_prop_string(ctx, base, \"\\xFF\" \"*").append(name).append("\");").append("\n")
					writer.append("\t// stack -> .... base .. ; [").append(name).append("] ; ").append(name).append("[*] ;").append("\n")
					writer.append("\n")
					writer.append("\tauto ptr").append(name).append(" = reinterpret_cast<").append(namespace).append("::").append(name).append("*>(duk_to_pointer(ctx, -1));").append("\n")
					writer.append("\tduk_pop_2(ctx);").append("\n")
					writer.append("\t// stack -> .... base .. ;").append("\n")
					writer.append("\n")
					writer.append("\treturn *ptr").append(name).append(";").append("\n")
					writer.append("}").append("\n")
					writer.append("#pragma endregion").append("\n")
			}
		}
	}

	object DukScaCC extends DukScaCC {
		def apply(module: Module): String = {
			val writer = new java.io.StringWriter()
			this (writer, module)
			writer.toString
		}
	}
}

